module PennAndTeller 

(*
  In E807 of "Penn and Teller: Fool Us", the magician "Hans" fools P&T with the following trick:
  1. He distributes large rock, piece of paper, and scissors to the three hosts, in order.
       penn gets the rock, teller gets the scissors, and alyson gets the paper
  2. He makes a prediction, asks one person to choose a swap to make (among any of the three players)
     who exchange props, and reveals "teller beats penn"..
  3. He makes a second prediction, asks two people to choose swaps to make, and reveals
       "alyson beats teller, penn beats alyson".
  4. He makes a third prediction, and asks each of the three people to choose a swap to make.
     On the prop piece of paper is his prediction
        "teller beats alyson, penn beats teller, alyson beats penn."

 Penn and Teller guessed that Hans had multiple outs covering all possiblities.  But the
 trick used another illusion, illustrated here using F*'s logic.  
*)

open FStar.List.Tot

type person = 
 | Penn
 | Teller
 | Alyson

let all_people = [Penn; Teller; Alyson]

type object = 
 | Rock
 | Paper
 | Scissors

// An assignment of person to object must be injective mapping
type assignment = (f:(person->object){forall x y. x <> y ==> f x <> f y})

// The rules of rock-paper-scissors
let beats (o1:object) (o2:object) : bool =
  match o1 with
  | Rock -> o2 = Scissors
  | Paper -> o2 = Rock
  | Scissors -> o2 = Paper

// Each player only beats one other player
// Prove that this is the case in the case of writing the function
let player_beats (a:assignment) (p:person) : (q:person{beats (a p) (a q)})  =
   let l = List.Tot.filter (fun (q:person) -> beats (a p) (a q)) all_people in
      // assert ( length l = 1 ); -- unnecessary, SMT figures it out!
      hd l

let start_assignment : assignment =
  fun p  -> match p with
  | Penn -> Rock
  | Teller -> Scissors
  | Alyson -> Paper

let other_person (p1:person) (p2:person{p1 <> p2}) : (p3:person{p1 <> p3 /\ p2 <> p3} ) =
  hd (List.Tot.filter (fun p -> p <> p1 && p <> p2) all_people)

let permute (a:assignment) 
  (p1:person) (p2:person{p1 <> p2}) (p3:person{p1 <> p3 /\ p2 <> p3})
  (q1:person) (q2:person{p1 <> p2}) (q3:person{p1 <> p3 /\ p2 <> p3})
  : person->object =
  fun (x:person) -> match x with
    | p1 -> (a q1)
    | p2 -> (a q2)
    | p3 -> (a q3)

// Cannot get this to work.  Why?  I don't know.
// I suspect the problem is that I'm not expressing the finite set in the correct way, so that
// if x = p1 and y = p2 then neither of them can be equal to p3; that's the assertion that fails.
// #set-options "--z3rlimit 120 --fuel 10 --ifuel 10"
[@@expect_failure]
let permute_is_assignment (a:assignment)
  (p1:person) (p2:person{p1 <> p2}) (p3:person{p1 <> p3 /\ p2 <> p3})
  (q1:person) (q2:person{p1 <> p2}) (q3:person{p1 <> p3 /\ p2 <> p3}) 
  : Lemma( forall (x:person) (y:person). x <> y ==> (permute a p1 p2 p3 q1 q2 q3)  x <> (permute a p1 p2 p3 q1 q2 q3) y )
  = let foo (x:person) (y:person) : Lemma (x <> y ==> (permute a p1 p2 p3 q1 q2 q3)  x <> (permute a p1 p2 p3 q1 q2 q3) y) = 
      let bar (ne:(x <> y)) : Lemma ((permute a p1 p2 p3 q1 q2 q3)  x <> (permute a p1 p2 p3 q1 q2 q3) y) = 
         match (x,y) with 
         | (p1, p2) -> assert( x <> y  ); assert (p1 <> p2 ); assert( x <> p3 ); ()
         | (p1, p3) -> admit()
         | (p2, p1) -> admit()
         | (p2, p3) -> admit()
         | (p3, p1) -> admit()
         | (p3, p2) -> admit()         
      in FStar.Classical.impl_intro bar
    in  
    FStar.Classical.forall_intro_2 foo
  
[@@expect_failure]
let transpose_assignment (a:assignment) (p1:person) (p2:person{p1 <> p2})  : assignment =
  let p3 = other_person p1 p2 in 
    permute_is_assignment a p1 p2 p3 p2 p1 p3;
    permute a p1 p2 p3 p2 p1 p3

// This is the full table that would be generated by the function above, if it worked.
let transpose_assignment2 (a:assignment) (p1:person) (p2:person{p1 <> p2})  : assignment =
  match (p1,p2) with
  | (Penn,Teller) -> ( fun p -> match p with | Penn -> (a Teller) | Teller -> (a Penn) | Alyson -> (a Alyson) )
  | (Teller,Penn) -> ( fun p -> match p with | Penn -> (a Teller) | Teller -> (a Penn) | Alyson -> (a Alyson) )
  | (Penn,Alyson) -> ( fun p -> match p with | Penn -> (a Alyson) | Teller -> (a Teller) | Alyson -> (a Penn) )
  | (Alyson,Penn) -> ( fun p -> match p with | Penn -> (a Alyson) | Teller -> (a Teller) | Alyson -> (a Penn) )
  | (Teller,Alyson) -> ( fun p -> match p with | Penn -> (a Penn) | Teller -> (a Alyson) | Alyson -> (a Teller) )
  | (Alyson,Teller) -> ( fun p -> match p with | Penn -> (a Penn) | Teller -> (a Alyson) | Alyson -> (a Teller) )

let theorem_all_transpositions_are_equivalent (x:assignment) (a1:person) (a2:person{a2<>a1}) (b1:person) (b2:person{b1<>b2}) 
 // Any two transpositions result in the same player outcomes
 : Lemma (ensures (forall p1 . player_beats (transpose_assignment2 x a1 a2) p1 = player_beats (transpose_assignment2 x b1 b2) p1)) =
   () 
